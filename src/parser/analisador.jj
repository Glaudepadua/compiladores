options{  IGNORE_CASE = true;  DEBUG_PARSER = true;  STATIC = false;}PARSER_BEGIN(Parser)package parser;import java.io.*;import recovery.*;public class Parser{  int countParseError = 0;  boolean debug_recovery = true;  public static void main(String args []) throws ParseException, TokenMgrError  {    Parser parser = null;    boolean debug_as = true;    if (args.length == 1)    {      System.out.println("\n Parser: Lendo a entrada ...\n");      parser = new Parser(System.in);    }    else if (args.length == 0)    {      try      {        System.out.println("\nParser: Lendo o arquivo ExemploCorreto ...\n");        parser = new Parser(new java.io.FileInputStream("ExemploCorreto.txt"));        parser.Start();        System.out.println("\nParser: Lendo o arquivo ExemploIncorreto ...\n");        parser = new Parser(new java.io.FileInputStream("ExemploIncorreto.txt"));        parser.Start();      }      catch (java.io.FileNotFoundException e)      {        System.out.println("Parser: O arquivo não foi encontrado.");        return;      }      catch (ParseEOFException e)      {        System.err.println(e.getMessage());      }      finally      {        //System.out.println(parser.token_source.foundLexError() + "Lexical Errors found");        System.out.println(parser.countParseError + "Syntactic Errors found");      }    }    else    {      System.out.println("Parser: Você deve usar da seguinte maneira:");      System.out.println(" java Parser < file");      System.out.println("Ou");      System.out.println(" java Parser file");      return;    }  }  static public String im(int x)  {    int k;    String s;    s = tokenImage [x];    k = s.lastIndexOf("\"");    try    {      s = s.substring(1, k);    }    catch (StringIndexOutOfBoundsException e)    {}    return s;  }  boolean eof;  void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException  {    Token tok;    if (debug_recovery)    {      System.out.println("\n *** " + met + " *** \n Syncronizing Set: " + g);    }    if (g == null) throw e;    tok = getToken(1);    while (!eof)    {      if (g.contains(tok.kind))      {        if (debug_recovery) System.out.println("Found syncronizing token: " + im(tok.kind));        break;      }      if (debug_recovery) System.out.println("Ignoring token: " + im(tok.kind));      getNextToken();      tok = getToken(1);      if (tok.kind == EOF && !g.contains(EOF)) eof = true;    }    System.out.println(e.getMessage());    countParseError++;    if (eof) throw new ParseEOFException("EOF found prematurely.");  }}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"| < "rem" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >}TOKEN :{  < INTEGER_CONSTANT : (< DIGIT >)+ >| < DOUBLE_CONSTANT :    (      (< DIGIT >)+ < DOT > (< DIGIT >)*    | (< DIGIT >)* < DOT > (< DIGIT >)+    ) >| < LOGIC_CONSTANT :    "true"  | "false" >| < STRING_CONSTANT :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      |        (          [ "\n", "\r" ]        | "\r\n"        )      )    )*    "\"" >| < #DIGIT : [ "0"-"9" ] >| < NULL_CONSTANT : "null" >| < VOID_CONSTANT : "void" >}TOKEN :{  < IF : "if" >| < FOR : "for" >| < WHILE : "while" >| < CLASS : "class" >| < INTERFACE : "interface" >| < EXTENDS : "extends" >| < IMPLEMENTS : "implements" >| < ELSE : "else" >| < STATIC : "static" >| < BREAK : "break" >| < STRING : "string" >| < INT : "int" >| < BOOLEAN : "boolean" >| < DOUBLE : "double" >| < LIST : "List" >| < NEW : "new" >| < MODIFIER :    "public"  | "private"  | "protected" >| < RETURN : "return" >| < SUPER : "super" >| < PRINT : "print" >| < READ : "read" >}TOKEN :{  < ASSIGN : "=" >| < GT : ">" >| < LT : "<" >| < EQ : "==" >| < GE : ">=" >| < LE : "<=" >| < NE : "!=" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < REM : "%" >}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < RBRACKET : "]" >| < LBRACKET : "[" >}TOKEN :{  < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : ([ "a"-"z", "A"-"Z" ]) >}void Start() throws ParseEOFException :{  RecoverySet g = First.Start;}{  < EOF >| classlist(g)  try  {    < EOF >  }  catch (ParseException e)  {    consumeUntil(g, e, "Start");  }  [ Start() ]}void classlist(RecoverySet g) throws ParseEOFException :{  RecoverySet f = First.classlist.union(g);}{  [ < MODIFIER > ]  (    classdecl(f) [ classlist(g) ]  | interfacedecl(g)  )}void interfacedecl(RecoverySet g) throws ParseEOFException :{}{  try  {    < INTERFACE > < IDENT > [ < EXTENDS > < IDENT > ] interfacebody(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "interfacedecl");  }}void interfacebody(RecoverySet g) throws ParseEOFException :{}{  try  {    (((type(g)  | < VOID_CONSTANT >) (< LBRACKET > < RBRACKET >) *)  | < LIST >) < IDENT > < SEMICOLON >  }  catch (ParseException e)  {    consumeUntil(g, e, "interfacebody");  }}void classdecl(RecoverySet g) throws ParseEOFException :{}{  try  {    < CLASS > < IDENT > [ < EXTENDS > < IDENT > ] [ < IMPLEMENTS > < INTERFACE > ] classbody(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "classdecl");  }}void classbody(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(RBRACE), f2 = new RecoverySet(SEMICOLON), f3 = First.methoddecl.union(f1), f4 = First.constructdecl.union(f3), f5 = First.vardecl.union(f4);}{  try  {    < LBRACE > (LOOKAHEAD(4)    [ < MODIFIER > ] vardecl(f2) < SEMICOLON >) * (LOOKAHEAD(2)    constructdecl(f4)) * (methoddecl(f3)) * < RBRACE >  }  catch (ParseException e)  {    consumeUntil(g, e, "classbody");  }}void vardecl(RecoverySet g) throws ParseEOFException :{}{  try  {    type(g) < IDENT > (< LBRACKET > < RBRACKET >) * (< COMMA > < IDENT > (< LBRACKET > < RBRACKET >) *) *  | < LIST > < LT > < GT > < IDENT > (< COMMA > < IDENT >) *  }  catch (ParseException e)  {    consumeUntil(g, e, "vardecl");  }}void constructdecl(RecoverySet g) throws ParseEOFException :{}{  try  {    [ < MODIFIER > ] < IDENT > methodbody(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "constructdecl");  }}void methoddecl(RecoverySet g) throws ParseEOFException :{}{  try  {    [ < MODIFIER > ] (((type(g)  | < VOID_CONSTANT >) (< LBRACKET > < RBRACKET >) *)  | < LIST >) < IDENT > methodbody(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "methoddecl");  }}void methodbody(RecoverySet g) throws ParseEOFException :{  RecoverySet f = new RecoverySet(RPAREN);}{  try  {    < LPAREN > paramlist(f) < RPAREN > statement(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "methodbody");  }}void paramlist(RecoverySet g) throws ParseEOFException :{}{  try  {    [      ((type(g) < IDENT > (< LBRACKET > < RBRACKET >) *)    | < LIST > < IDENT >) (< COMMA > (type(g) < IDENT > (< LBRACKET > < RBRACKET >) *)    | < LIST > < IDENT >) *    ]  }  catch (ParseException e)  {    consumeUntil(g, e, "paramlist");  }}void type(RecoverySet g) throws ParseEOFException :{}{  try  {    < INT >  | < STRING >  | < BOOLEAN >  | < DOUBLE >  | < IDENT >  }  catch (ParseException e)  {    consumeUntil(g, e, "type");  }}void statement(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(SEMICOLON);  RecoverySet f2 = new RecoverySet(RBRACE);}{  try  {    LOOKAHEAD(2)    vardecl(f1)  | atribstat(f1) < SEMICOLON >  | printstat(f1) < SEMICOLON >  | readstat(f1) < SEMICOLON >  | returnstat(f1) < SEMICOLON >  | superstat(f1) < SEMICOLON >  | ifstat(g)  | forstat(g)  | < LBRACE > statlist(f2) < RBRACE >  | < BREAK > < SEMICOLON >  | < SEMICOLON >  }  catch (ParseException e)  {    consumeUntil(g, e, "statement");  }}void atribstat(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(ASSIGN);}{  try  {    lvalue(f1) < ASSIGN > (alocexpression(g)  | expression(g))  }  catch (ParseException e)  {    consumeUntil(g, e, "atribstat");  }}void printstat(RecoverySet g) throws ParseEOFException :{}{  try  {    < PRINT > expression(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "printstat");  }}void readstat(RecoverySet g) throws ParseEOFException :{}{  try  {    < READ > lvalue(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "readstat");  }}void returnstat(RecoverySet g) throws ParseEOFException :{}{  try  {    < RETURN > [ expression(g) ]  }  catch (ParseException e)  {    consumeUntil(g, e, "returnstat");  }}void superstat(RecoverySet g) throws ParseEOFException :{  RecoverySet f = new RecoverySet(RPAREN);}{  try  {    < SUPER > < LPAREN > arglist(f) < RPAREN >  }  catch (ParseException e)  {    consumeUntil(g, e, "superstat");  }}void ifstat(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(RPAREN), f2 = new RecoverySet(ELSE).union(g);}{  try  {    < IF > < LPAREN > expression(f1) < RPAREN > statement(f2)    [      LOOKAHEAD(1)      < ELSE >      [        LOOKAHEAD(1)        statement(g)      ]    ]  }  catch (ParseException e)  {    consumeUntil(g, e, "ifstat");  }}void forstat(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(SEMICOLON), f2 = new RecoverySet(RPAREN);}{  try  {    < FOR > < LPAREN > [ atribstat(f1) ] < SEMICOLON > [ expression(f1) ] < SEMICOLON > [ atribstat(f2) ] < RPAREN > statement(g)  }  catch (ParseException e)  {    consumeUntil(g, e, "forstat");  }}void statlist(RecoverySet g) throws ParseEOFException :{  RecoverySet f = First.statlist.union(g);}{  statement(f) [ statlist(g) ]}void lvalue(RecoverySet g) throws ParseEOFException :{}{  try  {    < IDENT > (< LBRACKET > expression(null) < RBRACKET >  | < DOT > < IDENT > [ < LPAREN > arglist(null) < RPAREN > ]) *  }  catch (ParseException e)  {    consumeUntil(g, e, "lvalue");  }}void alocexpression(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(RPAREN), f2 = new RecoverySet(RBRACKET);}{  < NEW >  (    LOOKAHEAD(2)    (      < IDENT >    | < LIST >    )    < LPAREN > arglist(f1) < RPAREN >  |    (      type(g)    )    (      < LBRACKET > expression(f2) < RBRACKET >    )+  )}void expression(RecoverySet g) throws ParseEOFException :{}{  try  {    numexpr()    [      (< LT >    | < GT >    | < LE >    | < GE >    | < EQ >    | < NE >) numexpr()    ]  }  catch (ParseException e)  {    consumeUntil(g, e, "expression");  }}void numexpr() throws ParseEOFException :{}{  term()  (    (      < PLUS >    | < MINUS >    )    term()  )*}void term() throws ParseEOFException :{}{  unaryexpr()  (    (      < STAR >    | < SLASH >    | < REM >    )    unaryexpr()  )*}void unaryexpr() throws ParseEOFException :{}{  [    (      < PLUS >    | < MINUS >    )  ]  factor()}void factor() throws ParseEOFException :{}{  (    < INTEGER_CONSTANT >  | < STRING_CONSTANT >  | < NULL_CONSTANT >  | < DOUBLE_CONSTANT >  | lvalue(null)  | < LPAREN > expression(null) < RPAREN >  )}void arglist(RecoverySet g) throws ParseEOFException :{  RecoverySet f = new RecoverySet(COMMA).union(g);}{  [    expression(f)    (      < COMMA > expression(f)    )*  ]}