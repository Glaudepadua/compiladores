options{  IGNORE_CASE = true;  DEBUG_PARSER = true;  STATIC = false;}PARSER_BEGIN(Parser)package parser;import java.io.*;import recovery.*;import syntacticTree.*;import semanalysis.*;public class Parser{  int countParseError = 0;  boolean debug_recovery = true;  public static void main(String args []) throws ParseException, TokenMgrError  {    Parser parser = null;    boolean debug_as = true;    if (args.length == 1)    {      System.out.println("\n Parser: Lendo a entrada ...\n");      parser = new Parser(System.in);    }    else if (args.length == 0)    {      ListNode root = null;      try      {        parser = readFile("/exemplo/ExemploCorreto.txt");        root = parser.Start();        ;      }      catch (java.io.FileNotFoundException e)      {        System.out.println("Parser: O arquivo nÃ£o foi encontrado.");        return;      }      catch (ParseEOFException e)      {        System.err.println(e.getMessage());      }      finally      {        //System.out.println(parser.token_source.foundLexError() + "Lexical Errors found");        System.out.println(parser.countParseError + " erro(s) sintáticos encontrados.");      }      if ( //parser.token_source.foundLexError() +  verifica se pode operar sobre      parser.countParseError == 0)      {         if (print_tree) // exibir a árvore        {            PrintTree prt = new PrintTree();            prt.printRoot(root);     // chama método para imprimir árvore        }        TypeCheck tc = new TypeCheck();        try        {          tc.TypeCheckRoot(root);          System.out.println("0 Semantic Errors found");        }        catch (SemanticException e)        {          System.out.println(e.getMessage());        }      }    }    else    {      System.out.println("Parser: VocÃª deve usar da seguinte maneira:");      System.out.println(" java Parser < file");      System.out.println("Ou");      System.out.println(" java Parser file");      return;    }  }  static public String im(int x)  {    int k;    String s;    s = tokenImage [x];    k = s.lastIndexOf("\"");    try    {      s = s.substring(1, k);    }    catch (StringIndexOutOfBoundsException e)    {}    return s;  }  boolean eof;  void consumeUntil(RecoverySet g, ParseException e, String met) throws ParseEOFException, ParseException  {    Token tok;    if (debug_recovery)    {      System.out.println("\n *** " + met + " *** \n Set sincronizador: " + g);    }    if (g == null) throw e;    tok = getToken(1);    while (!eof)    {      if (g.contains(tok.kind))      {        if (debug_recovery) System.out.println("Token sincronizador encontrado: " + im(tok.kind));        break;      }      if (debug_recovery) System.out.println("Token ignorado: " + im(tok.kind));      getNextToken();      tok = getToken(1);      if (tok.kind == EOF && !g.contains(EOF)) eof = true;    }    System.out.println(e.getMessage());    countParseError++;    if (eof) throw new ParseEOFException("EOF found prematurely.");  }  static public Parser readFile(String file) throws FileNotFoundException  {    String current = System.getProperty("user.dir");    System.out.println("\nParser: Lendo o arquivo ...\n" + current);    return new Parser(new java.io.FileInputStream(current + file));  }}PARSER_END(Parser)SKIP :{  " "| "\t"| "\n"| "\r"| < "rem" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >}TOKEN :{  < INTEGER_CONSTANT : (< DIGIT >)+ >| < DOUBLE_CONSTANT :    (      (< DIGIT >)+ < DOT > (< DIGIT >)*    | (< DIGIT >)* < DOT > (< DIGIT >)+    ) >| < LOGIC_CONSTANT :    "true"  | "false" >| < STRING_CONSTANT :    "\""    (      ~[ "\"", "\\", "\n", "\r" ]    | "\\"      (        [ "n", "t", "b", "r", "f", "\\", "\'", "\"" ]      |        (          [ "\n", "\r" ]        | "\r\n"        )      )    )*    "\"" >| < #DIGIT : [ "0"-"9" ] >| < NULL_CONSTANT : "null" >| < VOID_CONSTANT : "void" >}TOKEN :{  < IF : "if" >| < FOR : "for" >| < WHILE : "while" >| < CLASS : "class" >| < INTERFACE : "interface" >| < EXTENDS : "extends" >| < IMPLEMENTS : "implements" >| < ELSE : "else" >| < STATIC : "static" >| < BREAK : "break" >| < STRING : "string" >| < INT : "int" >| < BOOLEAN : "boolean" >| < DOUBLE : "double" >| < LIST : "List" >| < NEW : "new" >| < MODIFIER :    "public"  | "private"  | "protected" >| < RETURN : "return" >| < SUPER : "super" >| < PRINT : "print" >| < READ : "read" >}TOKEN :{  < ASSIGN : "=" >| < GT : ">" >| < LT : "<" >| < EQ : "==" >| < GE : ">=" >| < LE : "<=" >| < NE : "!=" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < REM : "%" >}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < RBRACKET : "]" >| < LBRACKET : "[" >}TOKEN :{  < IDENT :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : ([ "a"-"z", "A"-"Z" ]) >}ListNode Start() throws ParseEOFException :{  RecoverySet g = First.Start;  ListNode l = null, d = null;}{  < EOF >  {    return null;  }| l = classlist(g)  try  {    < EOF >    {      return l;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "Start");  }  [ d = Start() ]  {    return l;  }}ListNode classlist(RecoverySet g) throws ParseEOFException :{  RecoverySet f = First.classlist.union(g);  ClassDeclNode c = null;  InterfaceDeclNode i = null;  ListNode l = null;  Token t = null;}{  [ t = < MODIFIER > ]  (    c = classdecl(f, t) [ l = classlist(g) ]  | i = interfacedecl(g, t)  )  {    return new ListNode(c, l);  } //FIX}InterfaceDeclNode interfacedecl(RecoverySet g, Token m) throws ParseEOFException :{  Token t = null, n = null, e1 = null;  InterfaceBodyNode i = null;}{  try  {    t = < INTERFACE > n = < IDENT > [ < EXTENDS > e1 = < IDENT > ] i = interfacebody(g)    {      return new InterfaceDeclNode(t, n, e1, m, i);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "interfacedecl");  }}InterfaceBodyNode interfacebody(RecoverySet g) throws ParseEOFException :{  Token t = null, t1 = null, t2 = null, t3 = null;  ListNode m = null;  MethodInterfaceDeclNode md;  int k = 0;}{  try  {    t = < LBRACE > ([ t3 = < MODIFIER > ] ((t1 = type(g)  | < VOID_CONSTANT >) (< LBRACKET > < RBRACKET >    {      k++;    }    ) *) t2 = < IDENT > < SEMICOLON >    {      if (m == null) m = new ListNode(new MethodInterfaceDeclNode(t1, k, t2, t3));      else m.add(new MethodInterfaceDeclNode(t1, k, t2, t3));    }    ) * < RBRACE >    {      return new InterfaceBodyNode(t, m);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "interfacebody");  }}ClassDeclNode classdecl(RecoverySet g, Token t4) throws ParseEOFException :{  Token t = null, n = null, e1 = null;  ClassBodyNode c = null;}{  try  {    t = < CLASS > n = < IDENT > [ < EXTENDS > e1 = < IDENT > ] [ < IMPLEMENTS > < INTERFACE > ] c = classbody(g)    {      return new ClassDeclNode(t, n, e1, t4, c);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "classdecl");    return new ClassDeclNode(t, n, e1, t4, c);  }}ClassBodyNode classbody(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(RBRACE), f2 = new RecoverySet(SEMICOLON), f3 = First.methoddecl.union(f1), f4 = First.constructdecl.union(f3), f5 = First.vardecl.union(f4);  ListNode v = null, ct = null, m = null;  VarDeclNode vd = null;  ConstructDeclNode cd = null;  MethodDeclNode md = null;  Token t = null;}{  try  {    t = < LBRACE > (LOOKAHEAD(4)    [ < MODIFIER > ] vd = vardecl(f2) < SEMICOLON >) *    {      if (v == null) v = new ListNode(vd);      else v.add(vd);    }    (LOOKAHEAD(2)    cd = constructdecl(f4)) *    {      if (ct == null) ct = new ListNode(cd);      else ct.add(cd);    }    (md = methoddecl(f3)    {      if (m == null) m = new ListNode(md);      else m.add(md);    }    ) * < RBRACE >    {      return new ClassBodyNode(t, v, ct, m);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "classbody");    return new ClassBodyNode(t, v, ct, m);  }}VarDeclNode vardecl(RecoverySet g) throws ParseEOFException :{  Token t1 = null, t2;  int k = 0;  ListNode l = null;}{  try  {    t1 = type(g) t2 = < IDENT > (< LBRACKET > < RBRACKET >    {      k++;    }    ) *    {      l = new ListNode(new VarNode(t2, k));    }    (< COMMA >    {      k = 0;    }    t2 = < IDENT > (< LBRACKET > < RBRACKET >) *    {      k++;    }    {      l.add(new VarNode(t2, k));    }    ) *    {      return new VarDeclNode(t1, l);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "vardecl");    return new VarDeclNode(t1, l);  }}ConstructDeclNode constructdecl(RecoverySet g) throws ParseEOFException :{  Token t = null;  MethodBodyNode m = null;}{  try  {    [ < MODIFIER > ] t = < IDENT > m = methodbody(g)    {      return new ConstructDeclNode(t, m);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "constructdecl");    return new ConstructDeclNode(t, m);  }}MethodDeclNode methoddecl(RecoverySet g) throws ParseEOFException :{  Token t1 = null, t2 = null, t3 = null;  int k = 0;  MethodBodyNode m = null;}{  try  {    [ t3 = < MODIFIER > ] ((t1 = type(g)  | t1 = < VOID_CONSTANT >) (< LBRACKET > < RBRACKET >    {      k++;    }    ) *) t2 = < IDENT > m = methodbody(g)    {      return new MethodDeclNode(t1, k, t2, t3, m);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "methoddecl");    return new MethodDeclNode(t1, k, t2, t3, m);  }}MethodBodyNode methodbody(RecoverySet g) throws ParseEOFException :{  RecoverySet f = new RecoverySet(RPAREN);  Token t1 = null;  ListNode l = null;  StatementNode s = null;}{  try  {    t1 = < LPAREN > l = paramlist(f) < RPAREN > s = statement(g)    {      return new MethodBodyNode(t1, l, s);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "methodbody");    return new MethodBodyNode(t1, l, s);  }}ListNode paramlist(RecoverySet g) throws ParseEOFException :{  ListNode p = null, q = null;  int k = 0;  Token t1 = null;  Token t2 = null;}{  try  {    [      (t1 = type(g) t2 = < IDENT > (< LBRACKET > < RBRACKET >      {        k++;      }      ) *      {        q = new ListNode(new VarNode(t2, k));        p = new ListNode(new VarDeclNode(t1, q));      }      ) (< COMMA >      {        k = 0;      }      (t1 = type(g) t2 = < IDENT > (< LBRACKET > < RBRACKET >      {        k++;      }      ) *      {        q = new ListNode(new VarNode(t2, k));        p = new ListNode(new VarDeclNode(t1, q));      }      )) *    ]    {      return p;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "paramlist");    return null;  }}Token type(RecoverySet g) throws ParseEOFException :{  Token t1 = null;}{  try  {    t1 = < INT >  | t1 = < STRING >  | t1 = < BOOLEAN >  | t1 = < DOUBLE >  | t1 = < IDENT >  | t1 = < LIST >    {      return t1;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "type");  }}StatementNode statement(RecoverySet g) throws ParseEOFException :{  RecoverySet f1 = new RecoverySet(SEMICOLON);  RecoverySet f2 = new RecoverySet(RBRACE);  StatementNode s = null;  ListNode l;  Token t1 = null;}{  try  {    LOOKAHEAD(2)    s = vardecl(f1)  | s = atribstat(f1) < SEMICOLON >  | s = printstat(f1) < SEMICOLON >  | s = readstat(f1) < SEMICOLON >  | s = returnstat(f1) < SEMICOLON >  | s = superstat(f1) < SEMICOLON >  | s = ifstat(g)  | s = forstat(g)  | s = whilestat(g)  | t1 = < LBRACE > l = statlist(f2) < RBRACE >    {      s = new BlockNode(t1, l);    }  | t1 = < BREAK > < SEMICOLON >    {      s = new BreakNode(t1);    }  | t1 = < SEMICOLON >    {      s = new NopNode(t1);    }    {      return s;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "statement");    return new NopNode(t1);  }}AtribNode atribstat(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null, e2 = null;  Token t1 = null;  RecoverySet f1 = new RecoverySet(ASSIGN).union(g);}{  try  {    e1 = lvalue(f1) t1 = < ASSIGN > (e2 = alocexpression(g)  | e2 = expression(g))    {      return new AtribNode(t1, e1, e2);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "atribstat");    return new AtribNode(t1, e1, e2);  }}PrintNode printstat(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null;  Token t = null;}{  try  {    t = < PRINT > e1 = expression(g)    {      return new PrintNode(t, e1);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "printstat");    return new PrintNode(t, e1);  }}ReadNode readstat(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null;  Token t = null;}{  try  {    t = < READ > e1 = lvalue(g)    {      return new ReadNode(t, e1);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "readstat");    return new ReadNode(t, e1);  }}ReturnNode returnstat(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null;  Token t = null;}{  try  {    t = < RETURN > [ e1 = expression(g) ]    {      return new ReturnNode(t, e1);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "returnstat");    return new ReturnNode(t, e1);  }}SuperNode superstat(RecoverySet g) throws ParseEOFException :{  ListNode l = null;  Token t = null;  RecoverySet f = new RecoverySet(RPAREN).union(g);}{  try  {    t = < SUPER > < LPAREN > l = arglist(f) < RPAREN >    {      return new SuperNode(t, l);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "superstat");    return new SuperNode(t, l);  }}IfNode ifstat(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null;  StatementNode s1 = null, s2 = null;  Token t = null;  RecoverySet f1 = new RecoverySet(RPAREN).union(g), f2 = new RecoverySet(ELSE).union(g);}{  try  {    t = < IF > < LPAREN > e1 = expression(f1) < RPAREN > s1 = statement(f2)    [      LOOKAHEAD(1)      < ELSE >      [        LOOKAHEAD(1)        s2 = statement(g)      ]    ]    {      return new IfNode(t, e1, s1, s2);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "ifstat");    return new IfNode(t, e1, s1, s2);  }}ForNode forstat(RecoverySet g) throws ParseEOFException :{  AtribNode s1 = null, s2 = null;  StatementNode s3 = null;  ExpreNode e1 = null;  Token t = null;  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g), f2 = new RecoverySet(RPAREN).union(g);}{  try  {    t = < FOR > < LPAREN > [ s1 = atribstat(f1) ] < SEMICOLON > [ e1 = expression(f1) ] < SEMICOLON > [ s2 = atribstat(f2) ] < RPAREN > s3 = statement(g)    {      return new ForNode(t, e1, s1, s2, s3);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "forstat");    return new ForNode(t, e1, s1, s2, s3);  }}WhileNode whilestat(RecoverySet g) throws ParseEOFException :{  StatementNode s1 = null;  ExpreNode e1 = null;  Token t = null;  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g), f2 = new RecoverySet(RPAREN).union(g);}{  try  {    t = < WHILE > < LPAREN > [ e1 = expression(f1) ] < RPAREN > s1 = statement(g)    {      return new WhileNode(t, e1, s1);    }  }  catch (ParseException e)  {    consumeUntil(g, e, "whilestat");    return new WhileNode(t, e1, s1);  }}ListNode statlist(RecoverySet g) throws ParseEOFException :{  ListNode l = null;  StatementNode s = null;  RecoverySet f = First.statlist.union(g);}{  s = statement(f) [ l = statlist(g) ]  {    return new ListNode(s, l);  }}ExpreNode lvalue(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null, e2 = null;  Token t1 = null, t2 = null;  ListNode l = null;}{  try  {    t1 = < IDENT >    {      e1 = new VarNode(t1);    }    (t1 = < LBRACKET > e2 = expression(null) < RBRACKET >    {      e1 = new IndexNode(t1, e1, e2);    }  | t1 = < DOT > t2 = < IDENT > [ < LPAREN > l = arglist(null) < RPAREN > ]    {      e1 = new CallNode(t1, e1, t2, l);    }    ) *    {      return e1;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "lvalue");    return new VarNode(t1);  }}ExpreNode alocexpression(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null, e2 = null;  ListNode l = null;  Token t1, t2;  RecoverySet f1 = new RecoverySet(RPAREN).union(g), f2 = new RecoverySet(RBRACKET).union(g);}{  t1 = < NEW >  (    LOOKAHEAD(2)    (      t2 = < IDENT >    | t2 = < LIST >    )    < LPAREN > l = arglist(f1) < RPAREN >    {      e1 = new NewObjectNode(t1, t2, l);    }  |    (      t2 = type(g)    )    (      < LBRACKET > e2 = expression(f2) < RBRACKET >      {        if (l == null) l = new ListNode(e2);        else l.add(e2);      }    )+    {      e1 = new NewArrayNode(t1, t2, l);    }  )  {    return e1;  }}ExpreNode expression(RecoverySet g) throws ParseEOFException :{  ExpreNode e1 = null, e2 = null;  Token t = null;}{  try  {    e1 = numexpr()    [      (t = < LT >    | t = < GT >    | t = < LE >    | t = < GE >    | t = < EQ >    | t = < NE >) e2 = numexpr()      {        e1 = new RelationalNode(t, e1, e2);      }    ]    {      return e1;    }  }  catch (ParseException e)  {    consumeUntil(g, e, "expression");    return new RelationalNode(t, e1, e2);  }}ExpreNode numexpr() throws ParseEOFException :{  ExpreNode e1 = null, e2;  Token t;}{  e1 = term()  (    (      t = < PLUS >    | t = < MINUS >    )    e2 = term()    {      e1 = new AddNode(t, e1, e2);    }  )*  {    return e1;  }}ExpreNode term() throws ParseEOFException :{  ExpreNode e1 = null, e2;  Token t;}{  e1 = unaryexpr()  (    (      t = < STAR >    | t = < SLASH >    | t = < REM >    )    e2 = unaryexpr()    {      e1 = new MultNode(t, e1, e2);    }  )*  {    return e1;  }}ExpreNode unaryexpr() throws ParseEOFException :{  ExpreNode e;  Token t = null;}{  [    (      t = < PLUS >    | t = < MINUS >    )  ]  e = factor()  {    return ((t == null) ? e : new UnaryNode(t, e));  }}ExpreNode factor() throws ParseEOFException :{  ExpreNode e = null;  Token t;}{  (    t = < INTEGER_CONSTANT >    {      e = new IntConstNode(t);    }  | t = < STRING_CONSTANT >    {      e = new StringConstNode(t);    }  | t = < NULL_CONSTANT >    {      e = new NullConstNode(t);    }  | t = < DOUBLE_CONSTANT >    {      e = new DoubleConstNode(t);    }  | e = lvalue(null)  | < LPAREN > e = expression(null) < RPAREN >  )  {    return e;  }}ListNode arglist(RecoverySet g) throws ParseEOFException :{  ListNode l = null;  ExpreNode e = null;  RecoverySet f = new RecoverySet(COMMA).union(g);}{  [    e = expression(f)    {      l = new ListNode(e);    }    (      < COMMA > e = expression(f)      {        l.add(e);      }    )*  ]  {    return l;  }}